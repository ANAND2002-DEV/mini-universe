<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Mini Universe â€“ Real Solar System</title>

<style>
  body { margin:0; overflow:hidden; background:black; }
</style>

<script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js"
  }
}
</script>
</head>

<body>

<script type="module">
import * as THREE from "three";
import { OrbitControls } from
  "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/controls/OrbitControls.js";

/* ================= SCENE ================= */
const scene = new THREE.Scene();

/* ================= CAMERA ================= */
const camera = new THREE.PerspectiveCamera(
  60,
  window.innerWidth / window.innerHeight,
  1,
  20000
);
camera.position.set(0, 180, 360);

/* ================= RENDERER ================= */
const renderer = new THREE.WebGLRenderer({ antialias:true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(window.devicePixelRatio);
document.body.appendChild(renderer.domElement);

/* ================= LIGHT ================= */
scene.add(new THREE.AmbientLight(0xffffff, 0.5));
scene.add(new THREE.PointLight(0xffffff, 2.5, 10000));

/* ================= CONTROLS (MAIN BASE) ================= */
const controls = new OrbitControls(camera, renderer.domElement);
controls.enablePan = false;
controls.enableZoom = false;
controls.enableDamping = true;
controls.dampingFactor = 0.15;
controls.rotateSpeed = 0.35;

/* ================= DRAG TRACK ================= */
let isDragging = false;
renderer.domElement.addEventListener("pointerdown",()=>isDragging=false);
renderer.domElement.addEventListener("pointermove",()=>isDragging=true);

/* ================= CUSTOM ZOOM ================= */
let zoomTarget = camera.position.length();
let ZOOM_MIN = 120;
let ZOOM_MAX = 3200;
const ZOOM_STEP = 120;
const ZOOM_SMOOTH = 0.08;

window.addEventListener("wheel",(e)=>{
  e.preventDefault();
  zoomTarget += Math.sign(e.deltaY)*ZOOM_STEP;
  zoomTarget = THREE.MathUtils.clamp(zoomTarget,ZOOM_MIN,ZOOM_MAX);
},{passive:false});

/* ================= STARS BACKGROUND ================= */
const starsGeo = new THREE.BufferGeometry();
const stars = [];
for(let i=0;i<9000;i++){
  stars.push(
    (Math.random()-0.5)*15000,
    (Math.random()-0.5)*15000,
    (Math.random()-0.5)*15000
  );
}
starsGeo.setAttribute("position",new THREE.Float32BufferAttribute(stars,3));
scene.add(new THREE.Points(
  starsGeo,
  new THREE.PointsMaterial({ color:0xffffff, size:1 })
));

/* ================= TEXTURES ================= */
const loader = new THREE.TextureLoader();

/* ================= SUN ================= */
const sun = new THREE.Mesh(
  new THREE.SphereGeometry(42,64,64),
  new THREE.MeshStandardMaterial({
    map: loader.load("./assets/planets/sun.jpg"),
    emissive:new THREE.Color(0xffaa00),
    emissiveIntensity:2
  })
);
scene.add(sun);

/* ================= PLANETS ================= */
const planetData = [
  { name:"Mercury", size:4,  dist:70,  speed:1.8,  tex:"mercury.jpg" },
  { name:"Venus",   size:6,  dist:95,  speed:1.5,  tex:"venus.jpg" },
  { name:"Earth",   size:7,  dist:120, speed:1.2,  tex:"earth.jpg" },
  { name:"Mars",    size:6,  dist:150, speed:1.0,  tex:"mars.jpg" },
  { name:"Jupiter", size:14, dist:200, speed:0.7,  tex:"jupiter.jpg" },
  { name:"Saturn",  size:13, dist:260, speed:0.45, tex:"saturn.jpg" },
  { name:"Uranus",  size:12, dist:320, speed:0.35, tex:"uranus.jpg" },
  { name:"Neptune", size:12, dist:380, speed:0.28, tex:"neptune.jpg" },
  { name:"Pluto",   size:5,  dist:440, speed:0.22, tex:"pluto.jpg" },
  { name:"Eris",    size:5,  dist:500, speed:0.18, tex:"eris.jpg" },
  { name:"Exoplanet",size:8, dist:560, speed:0.14, tex:"exoplanet.jpg" }
];

const planets=[];
const ORBIT_SPEED=0.00005;

/* ================= ORBIT LINES ================= */
planetData.forEach(p=>{
  const curve = new THREE.EllipseCurve(
    0,0,p.dist,p.dist,0,Math.PI*2
  );
  const points = curve.getPoints(128);
  const geo = new THREE.BufferGeometry().setFromPoints(
    points.map(pt=>new THREE.Vector3(pt.x,0,pt.y))
  );
  scene.add(new THREE.Line(
    geo,
    new THREE.LineBasicMaterial({ color:0xffffff, opacity:0.15, transparent:true })
  ));
});

/* ================= CREATE PLANETS ================= */
planetData.forEach(p=>{
  const mesh=new THREE.Mesh(
    new THREE.SphereGeometry(p.size,48,48),
    new THREE.MeshStandardMaterial({
      map:loader.load("./assets/planets/"+p.tex)
    })
  );
  scene.add(mesh);
  planets.push({...p,mesh,angle:Math.random()*Math.PI*2});
});

/* ================= ASTEROID BELT ================= */
const beltGeo = new THREE.BufferGeometry();
const beltPos=[];
for(let i=0;i<3000;i++){
  const r=THREE.MathUtils.randFloat(165,195);
  const a=Math.random()*Math.PI*2;
  beltPos.push(Math.cos(a)*r,THREE.MathUtils.randFloat(-2,2),Math.sin(a)*r);
}
beltGeo.setAttribute("position",new THREE.Float32BufferAttribute(beltPos,3));
scene.add(new THREE.Points(
  beltGeo,
  new THREE.PointsMaterial({ color:0x888888, size:1 })
));

/* ================= SPACE DUST ================= */
const dustGeo=new THREE.BufferGeometry();
const dust=[];
for(let i=0;i<4000;i++){
  dust.push(
    THREE.MathUtils.randFloatSpread(800),
    THREE.MathUtils.randFloatSpread(20),
    THREE.MathUtils.randFloatSpread(800)
  );
}
dustGeo.setAttribute("position",new THREE.Float32BufferAttribute(dust,3));
scene.add(new THREE.Points(
  dustGeo,
  new THREE.PointsMaterial({ color:0xffffff, size:0.5, opacity:0.4, transparent:true })
));

/* ================= SHOOTING STARS ================= */
const meteors=[];
function spawnMeteor(){
  const geo=new THREE.BufferGeometry().setFromPoints([
    new THREE.Vector3(0,0,0),
    new THREE.Vector3(THREE.MathUtils.randFloat(-50,50),0,THREE.MathUtils.randFloat(-200,-400))
  ]);
  const line=new THREE.Line(
    geo,
    new THREE.LineBasicMaterial({ color:0xffffff })
  );
  line.position.set(
    THREE.MathUtils.randFloat(-800,800),
    THREE.MathUtils.randFloat(100,400),
    THREE.MathUtils.randFloat(-800,800)
  );
  scene.add(line);
  meteors.push({line,life:60});
}
setInterval(spawnMeteor,3000);

/* ================= SELECTION ================= */
const raycaster=new THREE.Raycaster();
const mouse=new THREE.Vector2();
let selected=null;

window.addEventListener("click",(e)=>{
  if(isDragging) return;

  mouse.x=(e.clientX/window.innerWidth)*2-1;
  mouse.y=-(e.clientY/window.innerHeight)*2+1;
  raycaster.setFromCamera(mouse,camera);

  const hits=raycaster.intersectObjects(planets.map(p=>p.mesh));
  if(hits.length){
    selected=planets.find(p=>p.mesh===hits[0].object);
    ZOOM_MIN=selected.size*4;
    ZOOM_MAX=selected.dist*3;
    zoomTarget=selected.dist*2;
  }else{
    selected=null;
    controls.target.set(0,0,0);
    ZOOM_MIN=120; ZOOM_MAX=3200;
  }
});

/* ================= RESIZE ================= */
window.addEventListener("resize",()=>{
  camera.aspect=window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth,window.innerHeight);
});

/* ================= LOOP ================= */
function animate(){
  requestAnimationFrame(animate);

  planets.forEach(p=>{
    p.angle+=ORBIT_SPEED*p.speed;
    p.mesh.position.set(
      Math.cos(p.angle)*p.dist,
      0,
      Math.sin(p.angle)*p.dist
    );
  });

  if(selected) controls.target.copy(selected.mesh.position);

  const dir=camera.position.clone().sub(controls.target).normalize();
  const dist=camera.position.distanceTo(controls.target);
  camera.position.copy(
    controls.target.clone().add(
      dir.multiplyScalar(THREE.MathUtils.lerp(dist,zoomTarget,ZOOM_SMOOTH))
    )
  );

  meteors.forEach((m,i)=>{
    m.line.position.z+=8;
    if(--m.life<=0){
      scene.remove(m.line);
      meteors.splice(i,1);
    }
  });

  controls.update();
  renderer.render(scene,camera);
}
animate();
</script>

</body>
</html>
