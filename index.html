<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Mini Universe</title>
<style>
body { margin:0; overflow:hidden; background:black; }
</style>
</head>
<body>

<script type="module">
import * as THREE from "./three/three.module.min.js";

/* ================= SCENE & CAMERA ================= */
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(70, innerWidth/innerHeight, 0.1, 12000);

let theta=Math.PI/4, phi=Math.PI/3;
let radius=120, tTheta=theta, tPhi=phi, tRadius=radius;
let focus=null;

function getFocus(){
  if(focus){
    const v=new THREE.Vector3();
    focus.getWorldPosition(v);
    return v;
  }
  return new THREE.Vector3();
}

function updateCamera(){
  theta+=(tTheta-theta)*0.08;
  phi+=(tPhi-phi)*0.08;
  radius+=(tRadius-radius)*0.15;
  const f=getFocus();
  camera.position.set(
    f.x + radius*Math.sin(phi)*Math.sin(theta),
    f.y + radius*Math.cos(phi),
    f.z + radius*Math.sin(phi)*Math.cos(theta)
  );
  camera.lookAt(f);
}

/* ================= RENDERER ================= */
const renderer=new THREE.WebGLRenderer({antialias:true});
renderer.setSize(innerWidth,innerHeight);
renderer.outputEncoding=THREE.sRGBEncoding;
renderer.toneMapping=THREE.ACESFilmicToneMapping;
document.body.appendChild(renderer.domElement);

/* ================= LIGHTS ================= */
scene.add(new THREE.PointLight(0xffffff,180,0,2));
scene.add(new THREE.AmbientLight(0xffffff,0.6));

/* ================= STARFIELD ================= */
const starsGeo=new THREE.BufferGeometry();
const starPos=[];
for(let i=0;i<9000;i++){
  starPos.push(
    (Math.random()-0.5)*9000,
    (Math.random()-0.5)*9000,
    (Math.random()-0.5)*9000
  );
}
starsGeo.setAttribute("position",new THREE.Float32BufferAttribute(starPos,3));
scene.add(new THREE.Points(
  starsGeo,
  new THREE.PointsMaterial({size:1.4,color:0xffffff})
));

/* ================= TEXTURES ================= */
const loader=new THREE.TextureLoader();

/* ================= SUN ================= */
const sun=new THREE.Mesh(
  new THREE.SphereGeometry(8,64,64),
  new THREE.MeshBasicMaterial({map:loader.load("./assets/planets/sun.jpg")})
);
scene.add(sun);

/* ================= PLANETS ================= */
const planetData=[
 {size:1.2,dist:18,speed:0.0009,tex:"mercury.jpg"},
 {size:1.6,dist:24,speed:0.0007,tex:"venus.jpg"},
 {size:1.8,dist:30,speed:0.0006,tex:"earth.jpg",moons:1},
 {size:1.5,dist:36,speed:0.0005,tex:"mars.jpg"},
 {size:3.2,dist:48,speed:0.0003,tex:"jupiter.jpg",moons:3},
 {size:2.9,dist:62,speed:0.00025,tex:"saturn.jpg",moons:2},
 {size:2.5,dist:76,speed:0.0002,tex:"uranus.jpg"},
 {size:2.5,dist:90,speed:0.00015,tex:"neptune.jpg"},
 {size:1.2,dist:104,speed:0.0001,tex:"pluto.jpg"},
 {size:2.0,dist:120,speed:0.00008,tex:"exoplanet.jpg",moons:1}
];

const planets=[], clickable=[];

planetData.forEach(p=>{
  /* orbit ring */
  const ring=new THREE.Mesh(
    new THREE.RingGeometry(p.dist-0.04,p.dist+0.04,128),
    new THREE.MeshBasicMaterial({color:0xffffff,opacity:0.07,transparent:true})
  );
  ring.rotation.x=Math.PI/2;
  scene.add(ring);

  const pivot=new THREE.Object3D();
  pivot.rotation.y=Math.random()*Math.PI*2;
  scene.add(pivot);

  const planet=new THREE.Mesh(
    new THREE.SphereGeometry(p.size,48,48),
    new THREE.MeshStandardMaterial({
      map:loader.load("./assets/planets/"+p.tex),
      emissive:0x333333,
      emissiveIntensity:0.5
    })
  );
  planet.position.x=p.dist;
  pivot.add(planet);

  /* moons â€“ VERY CLOSE */
  const moonPivots=[];
  if(p.moons){
    for(let i=0;i<p.moons;i++){
      const mp=new THREE.Object3D();
      planet.add(mp);

      const moon=new THREE.Mesh(
        new THREE.SphereGeometry(p.size*0.18,24,24),
        new THREE.MeshStandardMaterial({color:0xffffff})
      );
      moon.position.x=p.size*(2.2+i*0.9); // ðŸ”‘ SAFE DISTANCE
      mp.add(moon);
      moonPivots.push(mp);
    }
  }

  planets.push({pivot,planet,moons:moonPivots,speed:p.speed});
  clickable.push(planet);
});

/* ================= SHOOTING STARS ================= */
const streaks=[];

function spawnShootingStar(){
  const geo=new THREE.CylinderGeometry(0.03,0.03,8,8);
  const mat=new THREE.MeshBasicMaterial({color:0xffffff});
  const s=new THREE.Mesh(geo,mat);
  s.rotation.z=Math.PI/2;
  s.position.set(
    (Math.random()-0.5)*600,
    300,
    (Math.random()-0.5)*600
  );
  s.userData.vel=new THREE.Vector3(6,-6,-4);
  scene.add(s);
  streaks.push(s);
}
setInterval(spawnShootingStar,4000);

/* ================= METEORS ================= */
function spawnMeteor(){
  const m=new THREE.Mesh(
    new THREE.SphereGeometry(0.25,8,8),
    new THREE.MeshBasicMaterial({color:0xffccaa})
  );
  m.position.set(
    (Math.random()-0.5)*800,
    (Math.random()*300)+200,
    (Math.random()-0.5)*800
  );
  m.userData.vel=new THREE.Vector3(
    (Math.random()-0.5)*1.5,
    -(0.6+Math.random()),
    (Math.random()-0.5)*1.5
  );
  scene.add(m);
  streaks.push(m);
}
setInterval(spawnMeteor,7000);

/* ================= INTERACTION ================= */
const raycaster=new THREE.Raycaster();
const mouse=new THREE.Vector2();
addEventListener("click",e=>{
  mouse.x=(e.clientX/innerWidth)*2-1;
  mouse.y=-(e.clientY/innerHeight)*2+1;
  raycaster.setFromCamera(mouse,camera);
  const hit=raycaster.intersectObjects(clickable);
  if(hit.length){
    focus=hit[0].object;
    tRadius=hit[0].object.geometry.parameters.radius*2;
  }
});

/* ================= CONTROLS ================= */
let drag=false,lx=0,ly=0;
addEventListener("mousedown",e=>{drag=true;lx=e.clientX;ly=e.clientY});
addEventListener("mouseup",()=>drag=false);
addEventListener("mousemove",e=>{
  if(!drag)return;
  tTheta-=(e.clientX-lx)*0.004;
  tPhi-=(e.clientY-ly)*0.004;
  tPhi=Math.max(0.3,Math.min(Math.PI-0.3,tPhi));
  lx=e.clientX;ly=e.clientY;
});
addEventListener("wheel",e=>{
  tRadius+=e.deltaY*0.08;
  tRadius=Math.max(1,Math.min(2000,tRadius));
});

/* ================= ANIMATE ================= */
function animate(){
  requestAnimationFrame(animate);
  updateCamera();
  sun.rotation.y+=0.00025;

  planets.forEach(p=>{
    p.pivot.rotation.y+=p.speed;
    p.planet.rotation.y+=0.0007;
    p.moons.forEach((m,i)=>m.rotation.y+=0.001+i*0.0005);
  });

  streaks.forEach((s,i)=>{
    s.position.add(s.userData.vel);
    if(s.position.length()>2000){
      scene.remove(s);
      streaks.splice(i,1);
    }
  });

  renderer.render(scene,camera);
}
animate();

/* ================= RESIZE ================= */
addEventListener("resize",()=>{
  camera.aspect=innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth,innerHeight);
});
</script>

</body>
</html>
