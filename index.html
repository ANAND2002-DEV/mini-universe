<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Mini Universe â€“ Real Space Effects</title>

<style>
  body { margin:0; overflow:hidden; background:black; }
</style>

<script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js"
  }
}
</script>
</head>

<body>

<script type="module">
import * as THREE from "three";
import { OrbitControls } from
  "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/controls/OrbitControls.js";

/* ================= SCENE ================= */
const scene = new THREE.Scene();

/* ================= CAMERA ================= */
const camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 1, 30000);
camera.position.set(0,180,360);

/* ================= RENDERER ================= */
const renderer = new THREE.WebGLRenderer({ antialias:true });
renderer.setSize(innerWidth, innerHeight);
renderer.setPixelRatio(devicePixelRatio);
document.body.appendChild(renderer.domElement);

/* ================= LIGHT ================= */
scene.add(new THREE.AmbientLight(0xffffff,0.4));
scene.add(new THREE.PointLight(0xffffff,2.5,20000));

/* ================= CONTROLS (MAIN BASE) ================= */
const controls = new OrbitControls(camera, renderer.domElement);
controls.enablePan=false;
controls.enableZoom=false;
controls.enableDamping=true;
controls.dampingFactor=0.15;

/* ================= DRAG ================= */
let isDragging=false;
renderer.domElement.addEventListener("pointerdown",()=>isDragging=false);
renderer.domElement.addEventListener("pointermove",()=>isDragging=true);

/* ================= CUSTOM ZOOM ================= */
let zoomTarget=camera.position.length();
let ZOOM_MIN=120, ZOOM_MAX=3200;
window.addEventListener("wheel",(e)=>{
  e.preventDefault();
  zoomTarget+=Math.sign(e.deltaY)*120;
  zoomTarget=THREE.MathUtils.clamp(zoomTarget,ZOOM_MIN,ZOOM_MAX);
},{passive:false});

/* ================= TEXTURES ================= */
const loader=new THREE.TextureLoader();

/* ================= SCALE ================= */
const PLANET_SCALE=2.2;
const SUN_SCALE=0.85;

/* ================= SUN ================= */
const sun=new THREE.Mesh(
  new THREE.SphereGeometry(42*SUN_SCALE,64,64),
  new THREE.MeshStandardMaterial({
    map:loader.load("./assets/planets/sun.jpg"),
    emissive:new THREE.Color(0xffaa00),
    emissiveIntensity:2
  })
);
scene.add(sun);

/* ================= PLANETS ================= */
const planetData=[
  {size:4,dist:70,speed:1.8,tex:"mercury.jpg"},
  {size:6,dist:95,speed:1.5,tex:"venus.jpg"},
  {size:7,dist:120,speed:1.2,tex:"earth.jpg"},
  {size:6,dist:150,speed:1.0,tex:"mars.jpg"},
  {size:14,dist:200,speed:0.7,tex:"jupiter.jpg"},
  {size:13,dist:260,speed:0.45,tex:"saturn.jpg"},
  {size:12,dist:320,speed:0.35,tex:"uranus.jpg"},
  {size:12,dist:380,speed:0.28,tex:"neptune.jpg"},
  {size:5,dist:440,speed:0.22,tex:"pluto.jpg"},
  {size:5,dist:500,speed:0.18,tex:"eris.jpg"},
  {size:8,dist:560,speed:0.14,tex:"exoplanet.jpg"}
];

const planets=[];
const ORBIT_SPEED=0.00035;

planetData.forEach(p=>{
  const mesh=new THREE.Mesh(
    new THREE.SphereGeometry(p.size*PLANET_SCALE,48,48),
    new THREE.MeshStandardMaterial({ map:loader.load("./assets/planets/"+p.tex) })
  );
  scene.add(mesh);
  planets.push({...p,mesh,angle:Math.random()*Math.PI*2});
});

/* ================= COSMIC DUST ================= */
const dustGeo=new THREE.BufferGeometry();
const dust=[];
for(let i=0;i<6000;i++){
  dust.push(
    THREE.MathUtils.randFloatSpread(1000),
    THREE.MathUtils.randFloatSpread(30),
    THREE.MathUtils.randFloatSpread(1000)
  );
}
dustGeo.setAttribute("position",new THREE.Float32BufferAttribute(dust,3));
const dustPoints=new THREE.Points(
  dustGeo,
  new THREE.PointsMaterial({ color:0xffffff, size:0.6, opacity:0.35, transparent:true })
);
scene.add(dustPoints);

/* ================= COMETS ================= */
const comets=[];
function spawnComet(){
  const comet=new THREE.Mesh(
    new THREE.SphereGeometry(2,16,16),
    new THREE.MeshBasicMaterial({ color:0xffffff })
  );
  comet.angle=Math.random()*Math.PI*2;
  comet.dist=THREE.MathUtils.randFloat(200,800);
  comet.speed=THREE.MathUtils.randFloat(0.004,0.008);
  scene.add(comet);
  comets.push(comet);
}
setInterval(spawnComet,8000);

/* ================= SHOOTING STARS ================= */
const shootingStars=[];
function spawnShootingStar(){
  const geo=new THREE.BufferGeometry().setFromPoints([
    new THREE.Vector3(0,0,0),
    new THREE.Vector3(0,0,-200)
  ]);
  const star=new THREE.Line(
    geo,
    new THREE.LineBasicMaterial({ color:0xffffff })
  );
  star.position.set(
    THREE.MathUtils.randFloat(-1200,1200),
    THREE.MathUtils.randFloat(200,600),
    THREE.MathUtils.randFloat(-1200,1200)
  );
  scene.add(star);
  shootingStars.push({star,life:40});
}
setInterval(spawnShootingStar,3000);

/* ================= LOOP ================= */
function animate(){
  requestAnimationFrame(animate);

  planets.forEach(p=>{
    p.angle+=ORBIT_SPEED*p.speed;
    p.mesh.position.set(Math.cos(p.angle)*p.dist,0,Math.sin(p.angle)*p.dist);
  });

  comets.forEach(c=>{
    c.angle+=c.speed;
    c.position.set(Math.cos(c.angle)*c.dist,0,Math.sin(c.angle)*c.dist);
  });

  shootingStars.forEach((s,i)=>{
    s.star.position.z-=25;
    if(--s.life<=0){
      scene.remove(s.star);
      shootingStars.splice(i,1);
    }
  });

  const dir=camera.position.clone().normalize();
  camera.position.lerp(dir.multiplyScalar(zoomTarget),0.08);

  controls.update();
  renderer.render(scene,camera);
}
animate();

window.addEventListener("resize",()=>{
  camera.aspect=innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth,innerHeight);
});
</script>

</body>
</html>
