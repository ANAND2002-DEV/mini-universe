<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Mini Universe â€“ NASA Zoom Fixed</title>

<style>
  body { margin:0; overflow:hidden; background:black; }
</style>

<!-- IMPORT MAP -->
<script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js"
  }
}
</script>
</head>

<body>

<script type="module">
import * as THREE from "three";
import { OrbitControls } from
  "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/controls/OrbitControls.js";

/* ================= SCENE ================= */
const scene = new THREE.Scene();

/* ================= CAMERA (ZOOM FIX) ================= */
const camera = new THREE.PerspectiveCamera(
  60,
  window.innerWidth / window.innerHeight,
  1,          // ðŸ”‘ prevents jump
  12000
);
camera.position.set(0, 180, 360);

/* ================= RENDERER ================= */
const renderer = new THREE.WebGLRenderer({ antialias:true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(window.devicePixelRatio);
document.body.appendChild(renderer.domElement);

/* ================= LIGHT ================= */
scene.add(new THREE.AmbientLight(0xffffff, 0.6));
const sunLight = new THREE.PointLight(0xffffff, 2.5, 6000);
scene.add(sunLight);

/* ================= CONTROLS (NASA FIXED) ================= */
const controls = new OrbitControls(camera, renderer.domElement);

controls.enablePan = false;
controls.enableRotate = true;
controls.enableZoom = true;

controls.enableDamping = true;
controls.dampingFactor = 0.18;

controls.rotateSpeed = 0.28;
controls.zoomSpeed = 0.05;     // ðŸ”‘ MAIN FIX

controls.minDistance = 70;     // ðŸ”’ prevents snap-in
controls.maxDistance = 2600;   // ðŸ”’ prevents snap-out

/* ================= STARS ================= */
const starsGeo = new THREE.BufferGeometry();
const starsPos = [];
for (let i = 0; i < 7000; i++) {
  starsPos.push(
    (Math.random() - 0.5) * 9000,
    (Math.random() - 0.5) * 9000,
    (Math.random() - 0.5) * 9000
  );
}
starsGeo.setAttribute("position", new THREE.Float32BufferAttribute(starsPos, 3));
scene.add(new THREE.Points(
  starsGeo,
  new THREE.PointsMaterial({ color:0xffffff, size:1 })
));

/* ================= TEXTURES ================= */
const loader = new THREE.TextureLoader();

/* ================= SUN ================= */
const sun = new THREE.Mesh(
  new THREE.SphereGeometry(42, 64, 64),
  new THREE.MeshStandardMaterial({
    map: loader.load("./assets/planets/sun.jpg"),
    emissive: new THREE.Color(0xffaa00),
    emissiveIntensity: 2
  })
);
scene.add(sun);

/* ================= PLANETS ================= */
const planetData = [
  { size:4,  dist:70,  speed:1.8,  tex:"mercury.jpg" },
  { size:6,  dist:95,  speed:1.5,  tex:"venus.jpg" },
  { size:7,  dist:120, speed:1.2,  tex:"earth.jpg" },
  { size:6,  dist:150, speed:1.0,  tex:"mars.jpg" },
  { size:14, dist:200, speed:0.7,  tex:"jupiter.jpg" },
  { size:13, dist:260, speed:0.45, tex:"saturn.jpg" },
  { size:12, dist:320, speed:0.35, tex:"uranus.jpg" },
  { size:12, dist:380, speed:0.28, tex:"neptune.jpg" },
  { size:5,  dist:440, speed:0.22, tex:"pluto.jpg" },
  { size:5,  dist:500, speed:0.18, tex:"eris.jpg" },
  { size:8,  dist:560, speed:0.14, tex:"exoplanet.jpg" }
];

const planets = [];
const ORBIT_SPEED = 0.00005;

planetData.forEach(p => {
  const mesh = new THREE.Mesh(
    new THREE.SphereGeometry(p.size, 48, 48),
    new THREE.MeshStandardMaterial({
      map: loader.load("./assets/planets/" + p.tex)
    })
  );
  scene.add(mesh);

  planets.push({
    mesh,
    angle: Math.random() * Math.PI * 2,
    dist: p.dist,
    speed: p.speed,
    size: p.size
  });
});

/* ================= CLICK TO LOCK ================= */
const raycaster = new THREE.Raycaster();
const mouse = new THREE.Vector2();
let selected = null;

window.addEventListener("click", e => {
  mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
  mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;

  raycaster.setFromCamera(mouse, camera);
  const hits = raycaster.intersectObjects(planets.map(p => p.mesh));

  if (hits.length) {
    selected = planets.find(p => p.mesh === hits[0].object);

    controls.minDistance = selected.size * 3;
    controls.maxDistance = selected.size * 80;
  } else {
    selected = null;
    controls.target.set(0, 0, 0);
    controls.minDistance = 70;
    controls.maxDistance = 2600;
  }
});

/* ================= RESIZE ================= */
window.addEventListener("resize", () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});

/* ================= LOOP ================= */
function animate() {
  requestAnimationFrame(animate);

  planets.forEach(p => {
    p.angle += ORBIT_SPEED * p.speed;
    p.mesh.position.set(
      Math.cos(p.angle) * p.dist,
      0,
      Math.sin(p.angle) * p.dist
    );
  });

  if (selected) {
    controls.target.copy(selected.mesh.position);
  }

  controls.update();
  renderer.render(scene, camera);
}
animate();
</script>

</body>
</html>
