<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Mini Universe ‚Äì NASA Zoom</title>
<style>
  body { margin:0; overflow:hidden; background:black; }
  canvas { display:block; }
</style>
</head>
<body>

<script type="module">
import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js";
import { OrbitControls } from "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/controls/OrbitControls.js";

/* üåå SCENE */
const scene = new THREE.Scene();

/* üé• CAMERA */
const camera = new THREE.PerspectiveCamera(
  60,
  window.innerWidth/window.innerHeight,
  0.1,
  5000
);
camera.position.set(0, 120, 260);

/* üñ•Ô∏è RENDERER */
const renderer = new THREE.WebGLRenderer({ antialias:true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(window.devicePixelRatio);
document.body.appendChild(renderer.domElement);

/* üí° LIGHT */
scene.add(new THREE.AmbientLight(0xffffff, 0.6));
const sunLight = new THREE.PointLight(0xffffff, 2, 2000);
scene.add(sunLight);

/* üéÆ CONTROLS (NASA STYLE) */
const controls = new OrbitControls(camera, renderer.domElement);
controls.enablePan = false;
controls.enableDamping = true;
controls.dampingFactor = 0.08;
controls.rotateSpeed = 0.4;
controls.zoomSpeed = 0.6;

/* ‚ú® STARS */
const starGeo = new THREE.BufferGeometry();
const starCount = 3000;
const starPos = [];
for (let i=0;i<starCount;i++){
  starPos.push(
    (Math.random()-0.5)*4000,
    (Math.random()-0.5)*4000,
    (Math.random()-0.5)*4000
  );
}
starGeo.setAttribute("position", new THREE.Float32BufferAttribute(starPos,3));
const starMat = new THREE.PointsMaterial({ color:0xffffff, size:1 });
scene.add(new THREE.Points(starGeo, starMat));

/* ‚òÄÔ∏è SUN */
const loader = new THREE.TextureLoader();
const sun = new THREE.Mesh(
  new THREE.SphereGeometry(30,64,64),
  new THREE.MeshStandardMaterial({
    map: loader.load("./assets/planets/sun.jpg"),
    emissive: new THREE.Color(0xffaa00),
    emissiveIntensity: 1.5
  })
);
scene.add(sun);

/* ü™ê PLANETS */
const planetData = [
  { size:4, dist:45, speed:1.6, tex:"mercury.jpg" },
  { size:7, dist:65, speed:1.3, tex:"venus.jpg" },
  { size:8, dist:85, speed:1.0, tex:"earth.jpg" },
  { size:6, dist:110, speed:0.8, tex:"mars.jpg" },
  { size:16, dist:150, speed:0.4, tex:"jupiter.jpg" },
  { size:14, dist:190, speed:0.3, tex:"saturn.jpg" },
  { size:11, dist:230, speed:0.2, tex:"uranus.jpg" },
  { size:11, dist:270, speed:0.15, tex:"neptune.jpg" }
];

const planets = [];
const ORBIT_SPEED = 0.0001;

planetData.forEach(p=>{
  const mesh = new THREE.Mesh(
    new THREE.SphereGeometry(p.size,48,48),
    new THREE.MeshStandardMaterial({
      map: loader.load("./assets/planets/"+p.tex)
    })
  );
  scene.add(mesh);

  planets.push({
    mesh,
    angle: Math.random()*Math.PI*2,
    dist: p.dist,
    speed: p.speed,
    size: p.size
  });
});

/* üéØ CLICK SELECT */
const raycaster = new THREE.Raycaster();
const mouse = new THREE.Vector2();
let selected = null;

window.addEventListener("click", e=>{
  mouse.x = (e.clientX/window.innerWidth)*2-1;
  mouse.y = -(e.clientY/window.innerHeight)*2+1;

  raycaster.setFromCamera(mouse,camera);
  const hits = raycaster.intersectObjects(planets.map(p=>p.mesh));

  if(hits.length){
    selected = planets.find(p=>p.mesh===hits[0].object);
    controls.target.copy(selected.mesh.position);
    controls.minDistance = selected.size*1.2;
    controls.maxDistance = selected.size*15;
  }else{
    selected = null;
    controls.target.set(0,0,0);
    controls.minDistance = 40;
    controls.maxDistance = 1000;
  }
});

/* üîÑ RESIZE */
window.addEventListener("resize", ()=>{
  camera.aspect = window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});

/* üöÄ LOOP */
function animate(){
  requestAnimationFrame(animate);

  planets.forEach(p=>{
    p.angle += ORBIT_SPEED * p.speed;
    p.mesh.position.set(
      Math.cos(p.angle)*p.dist,
      0,
      Math.sin(p.angle)*p.dist
    );
  });

  if(selected){
    controls.target.copy(selected.mesh.position);
  }

  controls.update();
  renderer.render(scene, camera);
}
animate();
</script>

</body>
</html>
