<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Mini Universe</title>
<style>
  body { margin:0; overflow:hidden; background:black; }
  canvas { display:block; }
  .label {
    position:absolute;
    color:white;
    font-size:12px;
    pointer-events:none;
    background:rgba(0,0,0,0.6);
    padding:2px 6px;
    border-radius:4px;
    transform:translate(-50%, -50%);
    display:none;
  }
</style>
</head>
<body>

<div id="label" class="label"></div>

<script type="module">
import * as THREE from './three/three.module.min.js';
import { OrbitControls } from './three/OrbitControls.js';

/* ---------- SCENE ---------- */
const scene = new THREE.Scene();

/* ---------- CAMERA ---------- */
const camera = new THREE.PerspectiveCamera(
  60,
  window.innerWidth / window.innerHeight,
  0.1,
  5000
);
camera.position.set(0, 120, 260);

/* ---------- RENDERER ---------- */
const renderer = new THREE.WebGLRenderer({ antialias:true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(window.devicePixelRatio);
document.body.appendChild(renderer.domElement);

/* ---------- CONTROLS ---------- */
const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.dampingFactor = 0.08;
controls.minDistance = 30;
controls.maxDistance = 900;

/* ---------- LIGHTS ---------- */
scene.add(new THREE.AmbientLight(0xffffff, 0.45));

const sunLight = new THREE.PointLight(0xffffff, 3, 3000);
sunLight.position.set(0,0,0);
scene.add(sunLight);

/* ---------- STAR BACKGROUND ---------- */
const stars = new THREE.BufferGeometry();
const starCount = 8000;
const starPos = [];

for (let i = 0; i < starCount; i++) {
  starPos.push(
    (Math.random() - 0.5) * 3000,
    (Math.random() - 0.5) * 3000,
    (Math.random() - 0.5) * 3000
  );
}
stars.setAttribute('position', new THREE.Float32BufferAttribute(starPos, 3));
scene.add(new THREE.Points(
  stars,
  new THREE.PointsMaterial({ color:0xffffff, size:1 })
));

/* ---------- TEXTURE LOADER ---------- */
const loader = new THREE.TextureLoader();

/* ---------- SUN ---------- */
const sun = new THREE.Mesh(
  new THREE.SphereGeometry(18, 64, 64),
  new THREE.MeshBasicMaterial({
    map: loader.load('./assets/planets/sun.jpg')
  })
);
scene.add(sun);

/* ---------- PLANETS DATA ---------- */
const planetsData = [
  { name:'Mercury', file:'mercury.jpg', r:3, d:30, speed:0.04 },
  { name:'Venus', file:'venus.jpg', r:4, d:45, speed:0.03 },
  { name:'Earth', file:'earth.jpg', r:4.5, d:65, speed:0.025 },
  { name:'Mars', file:'mars.jpg', r:3.5, d:85, speed:0.02 },
  { name:'Jupiter', file:'jupiter.jpg', r:9, d:120, speed:0.015 },
  { name:'Saturn', file:'saturn.jpg', r:8, d:160, speed:0.012 },
  { name:'Uranus', file:'uranus.jpg', r:6, d:200, speed:0.01 },
  { name:'Neptune', file:'neptune.jpg', r:6, d:240, speed:0.008 },
  { name:'Pluto', file:'pluto.jpg', r:2.5, d:280, speed:0.006 },
  { name:'Exoplanet', file:'exoplanet.jpg', r:5, d:330, speed:0.004 }
];

const planets = [];
const pivots = [];

/* ---------- CREATE PLANETS ---------- */
planetsData.forEach(p => {
  const pivot = new THREE.Object3D();
  scene.add(pivot);

  const planet = new THREE.Mesh(
    new THREE.SphereGeometry(p.r, 32, 32),
    new THREE.MeshStandardMaterial({
      map: loader.load(`./assets/planets/${p.file}`),
      emissiveIntensity: 0.4
    })
  );

  planet.position.x = p.d;
  planet.userData = { name: p.name };
  pivot.add(planet);

  pivots.push({ pivot, speed: p.speed });
  planets.push(planet);
});

/* ---------- CLICK TO FOCUS ---------- */
const raycaster = new THREE.Raycaster();
const mouse = new THREE.Vector2();
const label = document.getElementById('label');

window.addEventListener('click', e => {
  mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
  mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;

  raycaster.setFromCamera(mouse, camera);
  const hits = raycaster.intersectObjects(planets);

  if (hits.length > 0) {
    const obj = hits[0].object;
    controls.target.copy(obj.getWorldPosition(new THREE.Vector3()));
    label.innerText = obj.userData.name;
    label.style.display = 'block';
  }
});

/* ---------- LABEL FOLLOW ---------- */
function updateLabel() {
  if (label.style.display === 'none') return;
  const pos = controls.target.clone().project(camera);
  label.style.left = ((pos.x + 1) / 2) * window.innerWidth + 'px';
  label.style.top = ((-pos.y + 1) / 2) * window.innerHeight + 'px';
}

/* ---------- ANIMATE ---------- */
function animate() {
  requestAnimationFrame(animate);

  pivots.forEach(p => p.pivot.rotation.y += p.speed * 0.01);

  controls.update();
  updateLabel();
  renderer.render(scene, camera);
}

animate();

/* ---------- RESIZE ---------- */
window.addEventListener('resize', () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>
