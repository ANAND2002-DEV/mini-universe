<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Mini Universe â€“ Bright Realistic</title>

<style>
  body { margin:0; overflow:hidden; background:black; }
  canvas { display:block; }
</style>
</head>
<body>

<script type="module">
import * as THREE from './three/three.module.min.js';
import { OrbitControls } from './three/OrbitControls.js';

/* ---------- SCENE ---------- */
const scene = new THREE.Scene();

/* ---------- CAMERA ---------- */
const camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.1, 10000);
camera.position.set(0, 220, 520);

/* ---------- RENDERER ---------- */
const renderer = new THREE.WebGLRenderer({ antialias:true });
renderer.setSize(innerWidth, innerHeight);
renderer.setPixelRatio(devicePixelRatio);
renderer.outputEncoding = THREE.sRGBEncoding;
document.body.appendChild(renderer.domElement);

/* ---------- CONTROLS ---------- */
const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.dampingFactor = 0.07;
controls.minDistance = 20;
controls.maxDistance = 4500;

/* ---------- LIGHTING (KEY PART) ---------- */

// soft ambient
scene.add(new THREE.AmbientLight(0xffffff, 0.45));

// strong sun light
const sunLight = new THREE.PointLight(0xffffff, 8.5, 8000);
sunLight.position.set(0,0,0);
scene.add(sunLight);

// rim light (adds depth without killing texture)
const rimLight = new THREE.DirectionalLight(0xffffff, 1.2);
rimLight.position.set(-300, 200, -400);
scene.add(rimLight);

/* ---------- STARFIELD ---------- */
const starGeo = new THREE.BufferGeometry();
const starPos = [];
for (let i=0;i<16000;i++){
  starPos.push(
    (Math.random()-0.5)*7000,
    (Math.random()-0.5)*7000,
    (Math.random()-0.5)*7000
  );
}
starGeo.setAttribute('position', new THREE.Float32BufferAttribute(starPos,3));
scene.add(new THREE.Points(
  starGeo,
  new THREE.PointsMaterial({ color:0xffffff, size:1 })
));

/* ---------- TEXTURES ---------- */
const loader = new THREE.TextureLoader();

/* ---------- SUN ---------- */
const sun = new THREE.Mesh(
  new THREE.SphereGeometry(28, 64, 64),
  new THREE.MeshBasicMaterial({
    map: loader.load('./assets/planets/sun.jpg')
  })
);
scene.add(sun);

/* ---------- PLANET DATA ---------- */
const planets = [
  {name:'Mercury', tex:'mercury.jpg', r:3.8, d:65, speed:0.05, moons:0},
  {name:'Venus', tex:'venus.jpg', r:5.5, d:90, speed:0.042, moons:0},
  {name:'Earth', tex:'earth.jpg', r:6, d:120, speed:0.035, moons:1},
  {name:'Mars', tex:'mars.jpg', r:5, d:155, speed:0.03, moons:2},
  {name:'Jupiter', tex:'jupiter.jpg', r:14, d:215, speed:0.02, moons:4},
  {name:'Saturn', tex:'saturn.jpg', r:12, d:285, speed:0.017, moons:3},
  {name:'Uranus', tex:'uranus.jpg', r:9, d:350, speed:0.013, moons:2},
  {name:'Neptune', tex:'neptune.jpg', r:9, d:415, speed:0.01, moons:2}
];

const systems = [];

/* ---------- CREATE PLANETS ---------- */
planets.forEach(p => {

  const orbitPivot = new THREE.Object3D();
  orbitPivot.rotation.x = (Math.random()-0.5)*0.25;
  scene.add(orbitPivot);

  /* Orbit Ring */
  const ring = new THREE.Mesh(
    new THREE.RingGeometry(p.d-0.4, p.d+0.4, 128),
    new THREE.MeshBasicMaterial({
      color:0xffffff,
      transparent:true,
      opacity:0.3,
      side:THREE.DoubleSide
    })
  );
  ring.rotation.x = Math.PI/2;
  scene.add(ring);

  /* Planet */
  const planet = new THREE.Mesh(
    new THREE.SphereGeometry(p.r, 48, 48),
    new THREE.MeshStandardMaterial({
      map: loader.load('./assets/planets/'+p.tex),
      roughness:0.45,
      metalness:0.05,
      emissive:new THREE.Color(0x111111),
      emissiveIntensity:0.25
    })
  );

  planet.position.x = p.d;
  orbitPivot.add(planet);

  /* Moons */
  const moonPivots = [];
  for(let i=0;i<p.moons;i++){
    const pivot = new THREE.Object3D();
    planet.add(pivot);

    const moon = new THREE.Mesh(
      new THREE.SphereGeometry(1.6, 32, 32),
      new THREE.MeshStandardMaterial({
        map: loader.load('./assets/planets/moon.jpg'),
        roughness:0.7,
        metalness:0.02
      })
    );

    moon.position.x = 9 + i*3;
    pivot.rotation.y = Math.random()*Math.PI*2;
    pivot.add(moon);
    moonPivots.push(pivot);
  }

  systems.push({orbitPivot, speed:p.speed, moonPivots});
});

/* ---------- ANIMATION ---------- */
function animate(){
  requestAnimationFrame(animate);

  systems.forEach(s=>{
    s.orbitPivot.rotation.y += s.speed*0.01;
    s.moonPivots.forEach(m=> m.rotation.y += 0.01);
  });

  controls.update();
  renderer.render(scene,camera);
}
animate();

/* ---------- RESIZE ---------- */
addEventListener('resize',()=>{
  camera.aspect = innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
});
</script>
</body>
</html>
