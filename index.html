<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Mini Universe â€“ Main Base + Star Base</title>

<style>
  body { margin:0; overflow:hidden; background:black; }
</style>

<script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js"
  }
}
</script>
</head>

<body>
<script type="module">
import * as THREE from "three";
import { OrbitControls } from
"https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/controls/OrbitControls.js";

/* ================= SCENE ================= */
const scene = new THREE.Scene();

/* ================= CAMERA ================= */
const camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 1, 30000);
camera.position.set(0,180,360);

/* ================= RENDERER ================= */
const renderer = new THREE.WebGLRenderer({ antialias:true });
renderer.setSize(innerWidth, innerHeight);
renderer.setPixelRatio(devicePixelRatio);
document.body.appendChild(renderer.domElement);

/* ================= LIGHT ================= */
scene.add(new THREE.AmbientLight(0xffffff,0.5));
scene.add(new THREE.PointLight(0xffffff,2.5,20000));

/* ================= CONTROLS (LOCKED) ================= */
const controls = new OrbitControls(camera, renderer.domElement);
controls.enablePan = false;
controls.enableZoom = false;
controls.enableDamping = true;
controls.dampingFactor = 0.15;
controls.rotateSpeed = 0.35;

/* ================= DRAG TRACK ================= */
let isDragging = false;
renderer.domElement.addEventListener("pointerdown",()=>isDragging=false);
renderer.domElement.addEventListener("pointermove",()=>isDragging=true);

/* ================= CUSTOM ZOOM ================= */
let zoomTarget = camera.position.distanceTo(controls.target);
let ZOOM_MIN = 120;
let ZOOM_MAX = 5000;
const ZOOM_STEP = 120;
const ZOOM_SMOOTH = 0.08;

window.addEventListener("wheel",(e)=>{
  e.preventDefault();
  zoomTarget += Math.sign(e.deltaY) * ZOOM_STEP;
  zoomTarget = THREE.MathUtils.clamp(zoomTarget, ZOOM_MIN, ZOOM_MAX);
},{ passive:false });

/* ================= STAR BACKGROUND ================= */
const bgStarsGeo = new THREE.BufferGeometry();
const bgStars = [];
for(let i=0;i<18000;i++){
  const r = THREE.MathUtils.randFloat(6000,20000);
  const t = Math.random()*Math.PI*2;
  const p = Math.acos(THREE.MathUtils.randFloat(-1,1));
  bgStars.push(
    r*Math.sin(p)*Math.cos(t),
    r*Math.cos(p),
    r*Math.sin(p)*Math.sin(t)
  );
}
bgStarsGeo.setAttribute("position", new THREE.Float32BufferAttribute(bgStars,3));
scene.add(new THREE.Points(
  bgStarsGeo,
  new THREE.PointsMaterial({ color:0xffffff, size:1 })
));

/* ================= TEXTURES ================= */
const loader = new THREE.TextureLoader();

/* ================= SUN ================= */
const sun = new THREE.Mesh(
  new THREE.SphereGeometry(36,64,64),
  new THREE.MeshStandardMaterial({
    map: loader.load("./assets/planets/sun.jpg"),
    emissive: 0xffaa00,
    emissiveIntensity: 2
  })
);
scene.add(sun);

/* ================= PLANETS ================= */
const planetData = [
  {size:8,dist:70,speed:1.8,tex:"mercury.jpg"},
  {size:12,dist:95,speed:1.5,tex:"venus.jpg"},
  {size:14,dist:120,speed:1.2,tex:"earth.jpg"},
  {size:12,dist:150,speed:1.0,tex:"mars.jpg"},
  {size:26,dist:200,speed:0.7,tex:"jupiter.jpg"},
  {size:24,dist:260,speed:0.45,tex:"saturn.jpg"},
  {size:22,dist:320,speed:0.35,tex:"uranus.jpg"},
  {size:22,dist:380,speed:0.28,tex:"neptune.jpg"},
  {size:10,dist:440,speed:0.22,tex:"pluto.jpg"},
  {size:10,dist:500,speed:0.18,tex:"eris.jpg"},
  {size:16,dist:560,speed:0.14,tex:"exoplanet.jpg"}
];

const planets = [];
const ORBIT_SPEED = 0.00035;

planetData.forEach(p=>{
  const mesh = new THREE.Mesh(
    new THREE.SphereGeometry(p.size,48,48),
    new THREE.MeshStandardMaterial({
      map: loader.load("./assets/planets/"+p.tex)
    })
  );
  scene.add(mesh);
  planets.push({...p,mesh,angle:Math.random()*Math.PI*2});
});

/* ================= ORBIT RINGS ================= */
planetData.forEach(p=>{
  const curve = new THREE.EllipseCurve(0,0,p.dist,p.dist,0,Math.PI*2);
  const pts = curve.getPoints(160);
  const geo = new THREE.BufferGeometry().setFromPoints(
    pts.map(pt=>new THREE.Vector3(pt.x,0,pt.y))
  );
  scene.add(new THREE.Line(
    geo,
    new THREE.LineBasicMaterial({ color:0xffffff, opacity:0.12, transparent:true })
  ));
});

/* ================= MEMORY STAR BASE ================= */
const memoryStars = [];
const STAR_COLORS = [
  0x66ccff, // blue
  0xffcc66, // gold
  0xff66aa, // pink
  0x66ffaa, // green
  0xcc66ff  // purple
];

for(let i=0;i<25;i++){
  const color = STAR_COLORS[i % STAR_COLORS.length];
  const star = new THREE.Mesh(
    new THREE.SphereGeometry(4,16,16),
    new THREE.MeshBasicMaterial({ color })
  );

  const r = THREE.MathUtils.randFloat(800,1400);
  const theta = Math.random()*Math.PI*2;
  const phi = Math.acos(THREE.MathUtils.randFloat(-1,1));

  star.position.set(
    r*Math.sin(phi)*Math.cos(theta),
    r*Math.cos(phi),
    r*Math.sin(phi)*Math.sin(theta)
  );

  star.userData.isMemoryStar = true;
  star.userData.baseScale = 1;

  scene.add(star);
  memoryStars.push(star);
}

/* ================= SELECTION ================= */
const raycaster = new THREE.Raycaster();
const mouse = new THREE.Vector2();
let selected = null;

window.addEventListener("click",(e)=>{
  if(isDragging) return;

  mouse.x = (e.clientX/innerWidth)*2-1;
  mouse.y = -(e.clientY/innerHeight)*2+1;
  raycaster.setFromCamera(mouse,camera);

  const objects = [
    ...planets.map(p=>p.mesh),
    ...memoryStars
  ];

  const hits = raycaster.intersectObjects(objects);
  if(hits.length){
    const obj = hits[0].object;
    selected = obj;
    zoomTarget = obj.position.length() * 0.8;
    ZOOM_MIN = 40;
    ZOOM_MAX = 2000;
  } else {
    selected = null;
    controls.target.set(0,0,0);
    ZOOM_MIN = 120;
    ZOOM_MAX = 5000;
  }
});

/* ================= LOOP ================= */
function animate(){
  requestAnimationFrame(animate);

  planets.forEach(p=>{
    p.angle += ORBIT_SPEED * p.speed;
    p.mesh.position.set(
      Math.cos(p.angle)*p.dist,
      0,
      Math.sin(p.angle)*p.dist
    );
  });

  // twinkle stars
  memoryStars.forEach(s=>{
    s.scale.setScalar(
      s.userData.baseScale +
      Math.sin(Date.now()*0.002 + s.position.x)*0.2
    );
  });

  if(selected){
    controls.target.copy(selected.position);
  }

  const dir = camera.position.clone().sub(controls.target).normalize();
  const dist = camera.position.distanceTo(controls.target);
  camera.position.copy(
    controls.target.clone().add(
      dir.multiplyScalar(
        THREE.MathUtils.lerp(dist, zoomTarget, ZOOM_SMOOTH)
      )
    )
  );

  controls.update();
  renderer.render(scene,camera);
}
animate();

window.addEventListener("resize",()=>{
  camera.aspect = innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth,innerHeight);
});
</script>
</body>
</html>
