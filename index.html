<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Mini Universe â€“ MAIN BASE (Complete)</title>

<style>
  body { margin:0; overflow:hidden; background:black; font-family:Arial,sans-serif; }

  /* ===== SUN MEMORY MODAL ===== */
  #memoryModal{
    position:fixed;
    inset:0;
    background:rgba(0,0,0,0.75);
    display:none;
    align-items:center;
    justify-content:center;
    z-index:50;
  }
  .modal-card{
    background:#0b0b0b;
    border:1px solid rgba(255,200,80,0.4);
    border-radius:16px;
    padding:28px 32px;
    max-width:420px;
    text-align:center;
    color:#ffd27d;
    box-shadow:0 0 40px rgba(255,170,0,0.25);
  }
  .modal-card h2{
    margin:0 0 14px;
    font-weight:600;
    color:#ffcc66;
  }
  .modal-card p{
    line-height:1.7;
    font-size:16px;
    color:#ffe4a8;
  }
  .close-btn{
    margin-top:18px;
    cursor:pointer;
    color:#ffcc66;
    font-size:14px;
    opacity:0.85;
  }
  .close-btn:hover{ opacity:1; }
</style>

<script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js"
  }
}
</script>
</head>

<body>

<!-- ===== SUN MEMORY MODAL ===== -->
<div id="memoryModal">
  <div class="modal-card">
    <h2>ðŸŒž Our First Meeting</h2>
    <p id="meetingText"></p>
    <div class="close-btn" onclick="closeModal()">Close</div>
  </div>
</div>

<script type="module">
import * as THREE from "three";
import { OrbitControls } from
"https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/controls/OrbitControls.js";

/* ================= SUN MEMORY LOGIC ================= */
const FIRST_MEET_DATE = new Date("2025-09-27");

function daysSince(){
  return Math.floor((new Date() - FIRST_MEET_DATE) / (1000*60*60*24));
}
function updateMeetingText(){
  document.getElementById("meetingText").innerHTML = `
    From our first meet on <b>27 September 2025</b>,<br>
    our love keeps growing.<br><br>
    Itâ€™s been <b>${daysSince()} days</b>,<br>
    and our love is still growing ðŸ’›
  `;
}
updateMeetingText();

window.closeModal = ()=>{
  document.getElementById("memoryModal").style.display="none";
};
function openSunMemory(){
  updateMeetingText();
  document.getElementById("memoryModal").style.display="flex";
}

/* ================= SCENE ================= */
const scene = new THREE.Scene();

/* ================= CAMERA ================= */
const camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 1, 30000);
camera.position.set(0,180,360);

/* ================= RENDERER ================= */
const renderer = new THREE.WebGLRenderer({ antialias:true });
renderer.setSize(innerWidth, innerHeight);
renderer.setPixelRatio(devicePixelRatio);
document.body.appendChild(renderer.domElement);

/* ================= LIGHT ================= */
scene.add(new THREE.AmbientLight(0xffffff,0.5));
scene.add(new THREE.PointLight(0xffffff,2.5,20000));

/* ================= CONTROLS ================= */
const controls = new OrbitControls(camera, renderer.domElement);
controls.enablePan=false;
controls.enableZoom=false;
controls.enableDamping=true;
controls.dampingFactor=0.15;
controls.rotateSpeed=0.35;

/* ================= DRAG TRACK ================= */
let isDragging=false;
renderer.domElement.addEventListener("pointerdown",()=>isDragging=false);
renderer.domElement.addEventListener("pointermove",()=>isDragging=true);

/* ================= CUSTOM ZOOM ================= */
let zoomTarget=camera.position.distanceTo(controls.target);
let ZOOM_MIN=120, ZOOM_MAX=6000;
const ZOOM_STEP=120, ZOOM_SMOOTH=0.08;

window.addEventListener("wheel",(e)=>{
  e.preventDefault();
  zoomTarget+=Math.sign(e.deltaY)*ZOOM_STEP;
  zoomTarget=THREE.MathUtils.clamp(zoomTarget,ZOOM_MIN,ZOOM_MAX);
},{passive:false});

/* ================= BACKGROUND STARS ================= */
const bgGeo=new THREE.BufferGeometry();
const bg=[];
for(let i=0;i<18000;i++){
  const r=THREE.MathUtils.randFloat(6000,20000);
  const t=Math.random()*Math.PI*2;
  const p=Math.acos(THREE.MathUtils.randFloat(-1,1));
  bg.push(
    r*Math.sin(p)*Math.cos(t),
    r*Math.cos(p),
    r*Math.sin(p)*Math.sin(t)
  );
}
bgGeo.setAttribute("position",new THREE.Float32BufferAttribute(bg,3));
scene.add(new THREE.Points(
  bgGeo,
  new THREE.PointsMaterial({ color:0xffffff, size:1 })
));

/* ================= SUN ================= */
const loader=new THREE.TextureLoader();
const sun=new THREE.Mesh(
  new THREE.SphereGeometry(36,64,64),
  new THREE.MeshStandardMaterial({
    map:loader.load("./assets/planets/sun.jpg"),
    emissive:0xffaa00,
    emissiveIntensity:2
  })
);
sun.userData.type="sun";
scene.add(sun);

/* ================= PLANETS ================= */
const planetData=[
  {size:8,dist:70,speed:1.8,tex:"mercury.jpg"},
  {size:12,dist:95,speed:1.5,tex:"venus.jpg"},
  {size:14,dist:120,speed:1.2,tex:"earth.jpg"},
  {size:12,dist:150,speed:1.0,tex:"mars.jpg"},
  {size:26,dist:200,speed:0.7,tex:"jupiter.jpg"},
  {size:24,dist:260,speed:0.45,tex:"saturn.jpg"},
  {size:22,dist:320,speed:0.35,tex:"uranus.jpg"},
  {size:22,dist:380,speed:0.28,tex:"neptune.jpg"},
  {size:10,dist:440,speed:0.22,tex:"pluto.jpg"},
  {size:10,dist:500,speed:0.18,tex:"eris.jpg"},
  {size:16,dist:560,speed:0.14,tex:"exoplanet.jpg"}
];

const planets=[];
const ORBIT_SPEED=0.00035;

planetData.forEach(p=>{
  const mesh=new THREE.Mesh(
    new THREE.SphereGeometry(p.size,48,48),
    new THREE.MeshStandardMaterial({
      map:loader.load("./assets/planets/"+p.tex)
    })
  );
  mesh.userData.type="planet";
  scene.add(mesh);
  planets.push({...p,mesh,angle:Math.random()*Math.PI*2});
});

/* ================= ORBIT RINGS ================= */
planetData.forEach(p=>{
  const curve=new THREE.EllipseCurve(0,0,p.dist,p.dist,0,Math.PI*2);
  const pts=curve.getPoints(160);
  const geo=new THREE.BufferGeometry().setFromPoints(
    pts.map(pt=>new THREE.Vector3(pt.x,0,pt.y))
  );
  scene.add(new THREE.Line(
    geo,
    new THREE.LineBasicMaterial({ color:0xffffff, opacity:0.12, transparent:true })
  ));
});

/* ================= MEMORY STARS ================= */
const memoryStars=[];
const STAR_COLORS=[0x66ccff,0xffcc66,0xff66aa,0x66ffaa,0xcc66ff];
const STAR_RINGS=[
  {radius:720,count:8},
  {radius:900,count:9},
  {radius:1150,count:8}
];

STAR_RINGS.forEach((ring,ri)=>{
  for(let i=0;i<ring.count;i++){
    const star=new THREE.Mesh(
      new THREE.SphereGeometry(8,20,20),
      new THREE.MeshBasicMaterial({ color:STAR_COLORS[(i+ri)%STAR_COLORS.length] })
    );
    star.userData.type="star";

    const hit=new THREE.Mesh(
      new THREE.SphereGeometry(18,16,16),
      new THREE.MeshBasicMaterial({ visible:false })
    );
    hit.userData.type="starHit";
    star.add(hit);

    const a=(i/ring.count)*Math.PI*2;
    star.position.set(
      Math.cos(a)*ring.radius,
      THREE.MathUtils.randFloat(-40,40),
      Math.sin(a)*ring.radius
    );

    scene.add(star);
    memoryStars.push(star);
  }
});

/* ================= COMETS ================= */
const comets=[];
function spawnComet(){
  const head=new THREE.Mesh(
    new THREE.SphereGeometry(2.5,16,16),
    new THREE.MeshBasicMaterial({ color:0xffffff })
  );
  const tailGeo=new THREE.BufferGeometry();
  const tailPos=[];
  for(let i=0;i<100;i++) tailPos.push(0,0,-i*3);
  tailGeo.setAttribute("position",new THREE.Float32BufferAttribute(tailPos,3));
  const tail=new THREE.Points(
    tailGeo,
    new THREE.PointsMaterial({
      color:0x88ccff,
      size:2,
      opacity:0.9,
      transparent:true,
      depthWrite:false
    })
  );
  head.add(tail);
  head.position.set(
    THREE.MathUtils.randFloat(-2200,2200),
    THREE.MathUtils.randFloat(-900,900),
    THREE.MathUtils.randFloat(-2200,2200)
  );
  head.velocity=head.position.clone().normalize().multiplyScalar(-THREE.MathUtils.randFloat(8,14));
  head.tail=tail;
  scene.add(head);
  comets.push(head);
}
setInterval(spawnComet,7000);

/* ================= RAYCAST ================= */
const raycaster=new THREE.Raycaster();
const mouse=new THREE.Vector2();
let selected=null;

window.addEventListener("click",(e)=>{
  if(isDragging) return;
  mouse.x=(e.clientX/innerWidth)*2-1;
  mouse.y=-(e.clientY/innerHeight)*2+1;
  raycaster.setFromCamera(mouse,camera);

  const hits=raycaster.intersectObjects(
    [sun, ...planets.map(p=>p.mesh), ...memoryStars],
    true
  );

  if(hits.length){
    let obj=hits[0].object;
    if(obj.userData.type==="starHit") obj=obj.parent;

    if(obj.userData.type==="sun"){
      openSunMemory();
      selected=null;
      return;
    }

    selected=obj;
    zoomTarget=obj.position.length()*0.9;
    ZOOM_MIN=60;
    ZOOM_MAX=3000;
  } else {
    selected=null;
    controls.target.set(0,0,0);
    ZOOM_MIN=120;
    ZOOM_MAX=6000;
  }
});

/* ================= LOOP ================= */
function animate(){
  requestAnimationFrame(animate);

  planets.forEach(p=>{
    p.angle+=ORBIT_SPEED*p.speed;
    p.mesh.position.set(
      Math.cos(p.angle)*p.dist,
      0,
      Math.sin(p.angle)*p.dist
    );
  });

  memoryStars.forEach(s=>{
    s.scale.setScalar(1+Math.sin(Date.now()*0.002+s.position.x)*0.15);
  });

  comets.forEach((c,i)=>{
    c.position.add(c.velocity);
    c.tail.material.opacity-=0.003;
    c.velocity.add(c.position.clone().multiplyScalar(-0.00002));
    if(c.tail.material.opacity<=0){
      scene.remove(c);
      comets.splice(i,1);
    }
  });

  if(selected){
    controls.target.copy(selected.position);
  }

  const dir=camera.position.clone().sub(controls.target).normalize();
  const dist=camera.position.distanceTo(controls.target);
  camera.position.copy(
    controls.target.clone().add(
      dir.multiplyScalar(
        THREE.MathUtils.lerp(dist,zoomTarget,ZOOM_SMOOTH)
      )
    )
  );

  controls.update();
  renderer.render(scene,camera);
}
animate();

window.addEventListener("resize",()=>{
  camera.aspect=innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth,innerHeight);
});
</script>

</body>
</html>

